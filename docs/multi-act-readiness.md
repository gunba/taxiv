# Multi-Act Readiness Audit

**Date:** 2025-11-12  
**Author:** Codex agent review

## Summary
We reviewed ingestion, backend, and frontend code paths ahead of adding more legislation (new Acts) plus case/ruling datasets. The current implementation is tightly coupled to ITAA 1997 and lacks abstractions for selecting, ingesting, or querying additional corpora. The items below capture the highest-risk choke points so future work can target the right seams.

## Key Findings

1. **Backend search stack hardcodes ITAA1997.** `backend/services/search_filters.py:6-25`, `backend/services/unified_search.py:107-235`, and `backend/services/provision_tokens.py:23-68` pin `ACT_ID`/`ALLOWED_ACT` to `"ITAA1997"`. Every lookup, tokenizer, exclusion rule, and lexical SQL query filters or rewrites IDs for that act only, so even if other acts are ingested the APIs will never surface them. Refactor these modules to accept an `act_id` parameter (threaded from the HTTP request) and pull exclusion metadata from the database instead of module-level constants.
2. **Frontend assumes a single act.** `App.tsx:13-118` hardcodes `PRIMARY_ACT_ID = 'ITAA1997'` and `SideNav` only accepts one `actId` prop with no selector or `GET /capabilities` call. Users cannot toggle acts, and semantic-search results always load ITAA sections. Add an act picker bootstrapped from `/capabilities`, persist the selection (URL/query param or local storage), and plumb the chosen `act_id` through `api.getHierarchy`, `getProvisionByRefId`, and semantic search interactions.
3. **Ingestion pipeline is ITAA-specific by construction.** Even though `Config.ACT_ID` exists, `ingest/pipelines/itaa1997/run_pipeline.py:301-359` redefines `FILE_PATTERN = "ITAA1997_VOL{}_intermediate.json"`, expects definitions to live under `Section 995-1`, and shares module-level globals (e.g., `DEFINITIONS_995_1`). Bringing in another Act would require copy/pasting the entire pipeline. We need a base pipeline (phase orchestration + GraphAnalyzer wiring) plus act-specific adapters (style maps, volume patterns, definition anchors) so new inputs only override the bits that truly differ.
4. **Reference normalization defaults to ITAA1997.** `ingest/core/normalization.py:52-160` uses `default_act="ITAA1997"` whenever an acronym is missing, and the heuristics/patterns only cover a short list of legacy tax acts. Case law and other statutes will silently normalize to ITAA1997, producing incorrect `ref_id`s and graph edges. The normalization API should require the caller to pass the current act (GraphAnalyzer already knows it) and load act-specific heuristics/alias maps from data instead of hard-coded regex branches.
5. **LLM extraction guardrails only mention ITAA/TAA/GST.** The Gemini system prompt (`ingest/core/llm_extraction.py:165-219`) enumerates ITAA1997/1936, TAA1953, and GSTA1999. When we feed new acts, the model is biased toward those acronyms and may emit invalid prefixes. Externalize the allowed acronym set (per act) so prompts stay accurate as coverage grows.
6. **Document/case tables are unused.** `backend/models/semantic.py:21-80` defines `Document`, `DocumentChunk`, and `DocReference`, but no ingestion code populates them and no API exposes cases/rulings. Before scaling to rulings/case PDFs, decide whether they live alongside `provisions` (as new act IDs) or whether the dormant document tables become the canonical store. If the latter, wire up ingestion, embeddings, and search endpoints for those tables now so we can validate schema fit.
7. **Act-specific exclusion rules cannot vary per dataset.** Section 995-1 is excluded everywhere via `EXCLUDED_REF_IDS` (`backend/services/search_filters.py:6-25`), and relatedness ignores those internal IDs globally. Other acts will need their own exclusion lists (e.g., definitions chapters). Model these rules in a table keyed by act so search/relatedness can remain generic.

## Next Steps
* Define the product-level act/catalog experience (act picker, default scope, cross-act search expectations) and update the frontend bootstrapping flow accordingly.
* Introduce act-aware abstractions in backend services (request-scoped act_id, per-act config tables, queries filtered by the requested act). Ensure `/api/search/unified` accepts an `act_id` and defaults sensibly when omitted.
* Extract a reusable ingestion framework (shared phases + adapters) and author templates/tests for new acts or unstructured case documents so we stop duplicating stateful parser logic.
* Expand normalization + LLM prompt configs to load supported acts from data files, and add regression tests exercising at least one non-ITAA act to prevent future coupling regressions.
